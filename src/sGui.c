

#include "sGui.h"

// Allocates memory to hold a GraphicContext_t struct and opens a connection with the XServer
GraphicContext_t* sgui_OpenGraphicContext()
{
	GraphicContext_t* newContext = malloc(sizeof(GraphicContext_t));
	if(newContext == NULL)
	{
		fprintf(stderr, "sGui_Error: cannot allocate memory for a new GraphicContext_t, %s\n", strerror(errno));
		return NULL;
	}

	newContext->XDisplay = XOpenDisplay(NULL);		// Open connection with xServer
	if(newContext->XDisplay == NULL)			// Check if connection opening has failed
	{
		fprintf(stderr, "sGui_Error: cannot open connection with XServer\n");
		return NULL;
	}

	newContext->screenNum = DefaultScreen(newContext->XDisplay);
	newContext->width = DisplayWidth(newContext->XDisplay, newContext->screenNum);
	newContext->height = DisplayHeight(newContext->XDisplay, newContext->screenNum);

	return newContext;
}


// Close connection with xServer and deallocates the memory for the GraphicContext_t struct
void sgui_CloseGraphicContext(GraphicContext_t* context)
{
	if(context == NULL)
		return;

	XCloseDisplay(context->XDisplay);			// Close connection with xServer
	free(context);
}


// Allocate memory to hold a Window_t struct and creates an xWindow
Window_t* sgui_CreateWindow(GraphicContext_t* context, char* name, int x, int y, uint32_t width, uint32_t height, Color_t fgColor, Color_t bgColor)
{
	if(context == NULL)
		return NULL;

	Window_t* newWnd = malloc(sizeof(Window_t));
	if(newWnd == NULL)
	{
		fprintf(stderr, "sGui_Error: cannot allocate memory to create a new Window_t, %s\n", strerror(errno));
		return NULL;
	}

	newWnd->boundedGC = context;				// Bind the new window to given graphic context
	newWnd->properties.x = x;				// Initialize all the other properties
	newWnd->properties.y = y;
	newWnd->properties.width = (int) width;
	newWnd->properties.height = (int) height;
	newWnd->isActive = 1;					// TODO: This should depend on the return value of CreateXWindow
	newWnd->fgColor = fgColor;
	newWnd->bgColor = bgColor;
	newWnd->firstWidget = newWnd->lastWidget = NULL;

	newWnd->XWindow = sgui_CreateXWindow(context->XDisplay, context->screenNum, NULL, x, y, width, height, ExposureMask, fgColor, bgColor);
	sgui_SetWindowName(newWnd, name);

	sgui_MapXWindow(context->XDisplay, newWnd->XWindow);			// Map created window to screen

	newWnd->windowCloseAtom = XInternAtom(context->XDisplay, "WM_DELETE_WINDOW", 1);
	XSetWMProtocols(context->XDisplay, newWnd->XWindow, &newWnd->windowCloseAtom, 1);

	return newWnd;
}


// Destroy the xWindow and deallocate the Window_t struct
void sgui_DestroyWindow(Window_t* window)
{
	if(window == NULL)
		return;

	sgui_DestroyAllWidgets(window);
	sgui_DestroyXWindow(window->boundedGC->XDisplay, window->XWindow);

	free(window);
}


// This function clears the window and redraws all it's content
void sgui_RedrawWindow(Window_t* window)
{
	if(window != NULL && window->isActive == 1)
	{
		XClearWindow(window->boundedGC->XDisplay, window->XWindow);	// Clear the window

		Widget_t* curr = window->firstWidget;
		while(curr != NULL)						// Redraw all widgets
		{
			sgui_RedrawWidget(curr);
			curr = curr->next;
		}

		XSync(window->boundedGC->XDisplay, 0);
	}
}


// This function dispatches the input received by the given window, if no event has already been received then it blocks
// until one is received; NOTE that it displatches only 1 input event and then returns so it must be called in a while loop
// to handle all events received by a window
void sgui_UpdateWindow(Window_t* window)
{
	if(window != NULL && window->isActive == 1)
	{
		XEvent currEv;
		XNextEvent(window->boundedGC->XDisplay, &currEv);	// Get next event form XServer


		switch(currEv.type)
		{
			case ClientMessage:				// If user clicked on the X arrow to close the window
				if((Atom) currEv.xclient.data.l[0] == window->windowCloseAtom)
				{
					window->isActive = 0;
				}
				break;

			case Expose:
				sgui_RedrawWindow(window);
				break;

			default:					// Let someone else (a widget) handle the event
				sgui_DispatchEvent(window, currEv);
				break;
		}
	}
}


// Searches all the widgets list of the given window until it finds the widget which generated the event, if such widget is found then
// the respective callback is executed (if such callback was setted) otherwise the event is discarded (not handled)
void sgui_DispatchEvent(Window_t* window, XEvent event)
{
	Widget_t* currWidget = window->firstWidget;

	while(currWidget != NULL)				// Until there are widgets
	{
		if(event.xany.window == currWidget->XWindow)	// Check if the event was generated by the current widget
		{
			switch(event.type)
			{
				case ButtonPress:		// Handles left button press
					if(event.xbutton.type == ButtonPress)
					{
						if(currWidget->OnClick != NULL)	// If there is a valid callback then call it
							currWidget->OnClick(currWidget, NULL);
					}

					break;

				case EnterNotify:		// Handles cursor enetering the widget
					if(currWidget->OnHover != NULL)
						currWidget->OnHover(currWidget, NULL);

					break;

				case LeaveNotify:		// Handles cursor exiting the widget
					if(currWidget->OnHover != NULL)
						currWidget->OnOutHover(currWidget, NULL);

					break;

				case KeyPress:			// Handles keyboard buttons being pressed
				{
					char insertedChar;
					XLookupString(&event.xkey, &insertedChar, 1, NULL, NULL);

					if(currWidget->OnKeyPress != NULL && insertedChar != 0)
						currWidget->OnKeyPress(currWidget, &insertedChar);
					
				} 	break;
			}

			return;
		}

		currWidget = currWidget->next;
	}
}


// Return 1 if the window is still active, 0 otehrwise
int sgui_IsWindowActive(Window_t* window)
{
	if(window == NULL)
		return 0;

	return window->isActive;
}


// Set name for the given window
void sgui_SetWindowName(Window_t* window, char* name)
{
	if(window != NULL && name != NULL)
	{
		XStringListToTextProperty(&name, 1, &window->name);				// Convert char* to XTextProperty type
		XSetWMName(window->boundedGC->XDisplay, window->XWindow, &window->name);	// Set window's name
		XSetWMIconName(window->boundedGC->XDisplay, window->XWindow, &window->name);	// Set window's icon name
	}
}


// Sets the background color of specified window with given color
void sgui_SetWindowColor(Window_t* window, Color_t newFgColor, Color_t newBgColor)
{
	if(window == NULL)
		return;

	window->fgColor = newFgColor;
	window->bgColor = newBgColor;


	XSetWindowBorder(window->boundedGC->XDisplay, window->XWindow, newFgColor);		// Set new foreground color
	XSetWindowBackground(window->boundedGC->XDisplay, window->XWindow, newBgColor);		// Set new background color
	sgui_RedrawWindow(window);								// Redraw the window to update it
}



// Returns the current foreground and background colors for the specified window
void sgui_GetWindowColor(Window_t* window, Color_t* fgColor, Color_t* bgColor)
{
	if(window == NULL)
		return;

	if(fgColor != NULL)
		*fgColor = window->fgColor;

	if(bgColor != NULL)
		*bgColor = window->bgColor;
}


// Allocates a new widget of given type that will be contained in the specified window and that will have properties given as parameters;
// the function returns a pointer to the created widget for future use in other library's functions
Widget_t* sgui_CreateWidget(Window_t* window, WidgetType_t type, char* id, uint32_t x, uint32_t y, uint32_t width, uint32_t height, char* text,
				Color_t fgColor, Color_t bgColor, Color_t drawFgColor, Color_t drawBgColor, void (*onClick)(Widget_t*, void*),
				void (*onHover)(Widget_t*, void*), void (*onOutHover)(Widget_t*, void*), void (*onKeyPress)(Widget_t*, void*))
{
	if(window == NULL)
		return NULL;

	Widget_t* newWidget = malloc(sizeof(Widget_t));		// Allocate a new widget struct
	if(newWidget == NULL)					// Check if allocation has failed
	{
		fprintf(stderr, "sgui_Error: cannot allocate memory to create a new Widget_t, %s\n", strerror(errno));
		return NULL;
	}

	newWidget->type = type;					// Set widget's type
	newWidget->parent = window;				// Set widget's parent window
	newWidget->properties.x = (int) x;			// Set widget's position, dimensions and colors
	newWidget->properties.y = (int) y;
	newWidget->properties.width = (int) width;
	newWidget->properties.height = (int) height;
	newWidget->fgColor = fgColor;
	newWidget->bgColor = bgColor;
	newWidget->cursorPos = 0;

	newWidget->OnClick = onClick;				// Set widget's callback functions
	newWidget->OnHover = onHover;
	newWidget->OnOutHover = onOutHover;
	newWidget->OnKeyPress = onKeyPress;

	memset(newWidget->text, '\0', MAX_TEXT_SIZE);
	memset(newWidget->id, '\0', WIDGET_ID_SIZE);
	strncpy(newWidget->id, id, WIDGET_ID_SIZE);		// Set widget's id

	unsigned eventsToCatch = 0;				// Indicates which events the widget will listen to, this depends on widget's type

	switch(type)						// According to the widget's type set other properties
	{
		case SGUI_BUTTON:
			eventsToCatch = ExposureMask | ButtonPressMask | ButtonReleaseMask | EnterWindowMask | LeaveWindowMask;
			strncpy(newWidget->text, text, MAX_TEXT_SIZE);	// Copy text passed as parameter to display it on the widget
			newWidget->displayText = 1;
			break;

		case SGUI_TEXTFIELD:
			eventsToCatch = ExposureMask | ButtonPressMask | ButtonReleaseMask | KeyPressMask | KeyReleaseMask | EnterWindowMask | LeaveWindowMask;
			newWidget->displayText = 1;

			if(onKeyPress == NULL)			// If OnKeyPress callback is not given then use default
				newWidget->OnKeyPress = sgui_UpdateTextfield;
				
			break;

		case SGUI_TEXT:
			strncpy(newWidget->text, text, MAX_TEXT_SIZE);	// Copy text passed as parameter to display it on the widget
			newWidget->displayText = 1;
			break;

		default:
			newWidget->displayText = 0;
			break;
	}

	// Create native XLib's window for the widget
	newWidget->XWindow = sgui_CreateXWindow(window->boundedGC->XDisplay, window->boundedGC->screenNum, &window->XWindow, 
				(int) x, (int) y, width, height, eventsToCatch, fgColor, bgColor);

	// Load the default font
	//Font defaultFont = sgui_LoadXFont(window->boundedGC->XDisplay, NULL);

	newWidget->font = sgui_LoadXFont(window->boundedGC->XDisplay, NULL);

	// Create a GC for the widget
	newWidget->style = sgui_CreateXGC(window->boundedGC->XDisplay, newWidget->XWindow, drawFgColor, drawBgColor, 1, LineSolid, 
					CapRound, JoinBevel, FillSolid, newWidget->font->fid);

	sgui_MapXWindow(window->boundedGC->XDisplay, newWidget->XWindow);

	// Now let's add the new widget to the window's widget list
	if(window->firstWidget == NULL)
	{
		window->firstWidget = window->lastWidget = newWidget;
		newWidget->prev = newWidget->next = NULL;
	} else {
		window->lastWidget->next = newWidget;
		newWidget->prev = window->lastWidget;
		window->lastWidget = newWidget;
		newWidget->next = NULL;
	}

	return newWidget;
}

void sgui_DestroyWidget(Window_t* window, Widget_t* widget)
{
	if(window != NULL && widget != NULL)
	{
		if(widget->prev != NULL)			// Remove widget from window's widgets list
			widget->prev->next = widget->next;
		else
			window->firstWidget = widget->next;

		if(widget->next != NULL)
			widget->next->prev = widget->prev;
		else
			window->lastWidget = widget->prev;

		sgui_UnmapXWindow(window->boundedGC->XDisplay, widget->XWindow);

		if(widget->font != NULL)			// Unload font if there is one
			sgui_UnloadXFont(window->boundedGC->XDisplay, widget->font->fid);

		if(widget->style != 0)				// Destroy GC if there is one
		{
			sgui_DestroyXGC(window->boundedGC->XDisplay, widget->style);
		}

		sgui_DestroyXWindow(window->boundedGC->XDisplay, widget->XWindow);
		free(widget);
	}
}


// Deallocates all the widgets in the window passed as parameter
void sgui_DestroyAllWidgets(Window_t* window)
{
	if(window == NULL)
		return;

	Widget_t* curr = window->firstWidget;
	Widget_t* temp = NULL;

	while(curr != NULL)
	{
		temp = curr;
		curr = curr->next;
		
		sgui_DestroyWidget(window, temp);
	}

	window->firstWidget = window->lastWidget = NULL;
}


// Returns a pointer to the Widget_t with the given ID if such widget exist in the window, NULL otherwise
Widget_t* sgui_GetWidget(Window_t* window, const char* id)
{
	if(window != NULL && id != NULL)
	{
		Widget_t* curr = window->firstWidget;

		while(curr != NULL)
		{
			if(strcmp(curr->id, id) == 0)
				return curr;

			curr = curr->next;
		}
	}

	fprintf(stderr, "sgui_Warning: GetWidget() failed, found no match for widget with id: \"%s\"\n", id);
	return NULL;
}


// This function redraws the widget given as parameter
void sgui_RedrawWidget(Widget_t* widget)
{
	if(widget == NULL)
		return;

	XClearWindow(widget->parent->boundedGC->XDisplay, widget->XWindow);

	if(widget->displayText == 1)							// If the widget must display text
	{
		int textLen = strlen(widget->text);					// Get text length

		// Let's calculate the width of the text that we want to draw (it will be stored in character.width)
		int dir, ascent, descent;						// Those will not be used but if we pass null to XTextExtent() it throws a seg fault error so here they are...
		XCharStruct character;
		XTextExtents(widget->font, widget->text, textLen, &dir, &ascent, &descent, &character);

		int textX = (widget->properties.width / 2) - (character.width / 2);	// Calculate x position for text
		int textY = (widget->properties.height / 2);				// Calculate y position for text

		XDrawString(widget->parent->boundedGC->XDisplay, widget->XWindow, widget->style, textX, textY, widget->text, textLen);
	}

	XSync(widget->parent->boundedGC->XDisplay, 0);
}


// Set widget's position to given coordinates
void sgui_SetWidgetPosition(Widget_t* widget, uint32_t x, uint32_t y)
{
	if(widget == NULL)
		return;

	widget->properties.x = (int) x;				// Set new x and y position
	widget->properties.y = (int) y;

	XConfigureWindow(widget->parent->boundedGC->XDisplay, widget->XWindow, CWX | CWY, &widget->properties);
	sgui_MapXWindow(widget->parent->boundedGC->XDisplay, widget->XWindow);
}


// Set widget's dimensions to given values
void sgui_SetWidgetDimension(Widget_t* widget, uint32_t width, uint32_t height)
{
	if(widget == NULL)
		return;

	widget->properties.width = (int) width;			// Set new width and height
	widget->properties.height = (int) height;

	XConfigureWindow(widget->parent->boundedGC->XDisplay, widget->XWindow, CWWidth | CWHeight, &widget->properties);
	widget->properties.height = (int) height;

	XConfigureWindow(widget->parent->boundedGC->XDisplay, widget->XWindow, CWWidth | CWHeight, &widget->properties);
}


// Set widget's color, Note: newFgColor is the widget's foreground color, newBgColor is the widget's background color
// newDrawFgColor is the foreground color used to draw inside the widget and newDrawGbColor is the background color used 
// to draw inside the widget
void sgui_SetWidgetColor(Widget_t* widget, Color_t newFgColor, Color_t newBgColor, Color_t newDrawFgColor, Color_t newDrawBgColor)
{
	if(widget == NULL)
		return;

	widget->fgColor = newFgColor;
	widget->bgColor = newBgColor;

	XSetWindowBorder(widget->parent->boundedGC->XDisplay, widget->XWindow, newFgColor);
	XSetWindowBackground(widget->parent->boundedGC->XDisplay, widget->XWindow, newBgColor);

	XSetForeground(widget->parent->boundedGC->XDisplay, widget->style, (unsigned long) newDrawFgColor);
	XSetBackground(widget->parent->boundedGC->XDisplay, widget->style, (unsigned long) newDrawBgColor);
	sgui_RedrawWidget(widget);
}


// Assigns the given string to the widget's text buffer and set if text is visible
void sgui_SetWidgetText(Widget_t* widget, const char* newText, uint8_t isVisible)
{
	if(widget == NULL)
		return;

	if(newText != NULL)					// Set new widget's text  if given
		strncpy(widget->text, newText, MAX_TEXT_SIZE);

	if(isVisible == 0)					// Set visibility of text
		widget->displayText = 0;
	else
		widget->displayText = 1;

	sgui_RedrawWidget(widget);
}


// Sets the font used to draw text in the widget to the given font (fontName must be a valid XLib's font name)
// if given font name is NULL then "fixed" will be used ("fixed" font should be available on almost all platforms)
// NOTE: If you call this function trying to load the font that is currently in use by the widget then you get an XLib error
// this is due to the fact that we unload the "old font" before setting the "new one" but those are the SAME font so it's like if
// we are trying to set a font that we unloaded
void sgui_SetWidgetFont(Widget_t* widget, const char* fontName)
{
	if(widget == NULL)
		return;

	XFontStruct* newFont = sgui_LoadXFont(widget->parent->boundedGC->XDisplay, fontName);
	if(newFont == NULL)
		return;

	if(widget->font != NULL)				// Unload current font if there is one
		sgui_UnloadXFont(widget->parent->boundedGC->XDisplay, widget->font->fid);
	
	XSetFont(widget->parent->boundedGC->XDisplay, widget->style, newFont->fid);
	sgui_RedrawWidget(widget);
}


// Set widget's callback functions
void sgui_SetWidgetCallback(Widget_t* widget, void (*onClick)(Widget_t*, void*), void (*onHover)(Widget_t*, void*),
			void (*onOutHover)(Widget_t*, void*), void (*onKeyPress)(Widget_t*, void*))
{
	if(widget == NULL)
		return;

	widget->OnClick = onClick;
	widget->OnHover = onHover;
	widget->OnOutHover = onOutHover;
	widget->OnKeyPress = onKeyPress;
}


// Writes the position of the specified widget in the given memory locations
void sgui_GetWidgetPosition(Widget_t* widget, uint32_t* x, uint32_t* y)
{
	if(widget == NULL)
		return;

	if(x != NULL)
		*x = (uint32_t) widget->properties.x;

	if(y != NULL)
		*y = (uint32_t) widget->properties.y;
}


// Writes the dimensions of the specified widget in the given memory locations
void sgui_GetWidgetDimension(Widget_t* widget, uint32_t* width, uint32_t* height)
{
	if(widget == NULL)
		return;

	if(width != NULL)
		*width = (uint32_t) widget->properties.width;

	if(height != NULL)
		*height = (uint32_t) widget->properties.height;
}


// Writes the colors of the specified windget in the given memory locations
void sgui_GetWidgetColor(Widget_t* widget, Color_t* fgColor, Color_t* bgColor, Color_t* drawFgColor, Color_t* drawBgColor)
{
	if(widget == NULL)
		return;

	if(fgColor != NULL)
		*fgColor = widget->fgColor;

	if(bgColor != NULL)
		*bgColor = widget->bgColor;

	if(widget->style != 0)					// If widget has a valid style
	{
		XGCValues vals;
		XGetGCValues(widget->parent->boundedGC->XDisplay, widget->style, GCForeground | GCBackground, &vals);

		if(drawFgColor != NULL)
			*drawFgColor = (Color_t) vals.foreground;

		if(drawBgColor != NULL)
			*drawBgColor = (Color_t) vals.background;
	}
}


// Returns a pointer to the text buffer of the specified widget
char* sgui_GetWidgetText(Widget_t* widget)
{
	if(widget != NULL)
		return widget->text;

	return NULL;
}


// Writes the callback functions of the specified widget in the given memory locations
void sgui_GetWidgetCallback(Widget_t* widget, void (**onClick)(Widget_t*, void*), void (**onHover)(Widget_t*, void*),
				void (**onOutHover)(Widget_t*, void*), void (**onKeyPress)(Widget_t*, void*))
{
	if(widget == NULL)
		return;

	if(onClick != NULL)
		*onClick = widget->OnClick;

	if(onHover != NULL)
		*onHover = widget->OnHover;

	if(onOutHover != NULL)
		*onOutHover = widget->OnOutHover;

	if(onKeyPress != NULL)
		*onKeyPress = widget->OnKeyPress;
}


// Creates a native XWindow with given properties
Window sgui_CreateXWindow(Display* display, int screenNum, Window* parent, int x, int y, uint32_t width, uint32_t height, unsigned catchEventsMask, Color_t fgColor, Color_t bgColor)
{
	Window newXWindow;
	Window newWndFather;

	if(display == NULL)
	{
		fprintf(stderr, "sgui_Error: trying to create an XWindow with a null Display* as parameter\n");
		return newXWindow;
	}

	if(parent == NULL)				// If parent is not given then set new window's father as root window
		newWndFather = RootWindow(display, screenNum);
	else						// Otherwise use the given window
		newWndFather = *parent;
	

	// Create a struct that defines background color, border color and events that we want to listen for new window
	XSetWindowAttributes defaultAttrs;
	defaultAttrs.background_pixel = bgColor;
	defaultAttrs.border_pixel = fgColor;
	defaultAttrs.event_mask = catchEventsMask;

	unsigned long settedAttrs = CWBackPixel | CWBorderPixel | CWEventMask;	// Indicates which attributes are setted in defaultAttrs struct
	
	newXWindow = XCreateWindow(display, newWndFather, x, y, width, height, 1, DefaultDepth(display, screenNum),
					InputOutput, DefaultVisual(display, screenNum), settedAttrs, &defaultAttrs);

	return newXWindow;
}


// Destroyes the native XWindow passed as parameter
void sgui_DestroyXWindow(Display* display, Window window)
{
	if(display == NULL)
		return;

	XDestroyWindow(display, window);
}


// Creates a native GraphicContext "GC" 
GC sgui_CreateXGC(Display* display, Window window, Color_t fgColor, Color_t bgColor, int lineWidth, int lineStyle, int capStyle, int joinStyle, int fillStyle, Font font)
{
	if(display == NULL)
		return 0;

	XGCValues vals;						// Native struct that defines properties of the native GC
	
	vals.foreground = (unsigned long) fgColor;		// Set struct's properties
	vals.background = (unsigned long) bgColor;
	vals.line_width = lineWidth;
	vals.line_style = lineStyle;
	vals.cap_style = capStyle;
	vals.join_style = joinStyle;
	vals.fill_style = fillStyle;
	vals.font = font;

	unsigned long propertiesMask = GCForeground | GCBackground | GCLineWidth | GCLineStyle | GCCapStyle | GCJoinStyle | GCFont;

	GC newGC = XCreateGC(display, window, propertiesMask, &vals);	// Create GC

	if(newGC == 0)						// Check if GC creation failed
	{
		fprintf(stderr, "sGui_Error: cannot create GC (native GraphicContext)\n");
	}

	return newGC;
}


// Destroyes the native GraphicContext "GC" given as parameter
void sgui_DestroyXGC(Display* display, GC gc)
{
	if(display != NULL && gc != 0)
	{		
		XFreeGC(display, gc);
	}
}


// Loads and returns the font specified by fontName, if font is not found (or fontName is NULL) it returns a default one ("fixed")
// if some error occurs then NULL is returned
XFontStruct* sgui_LoadXFont(Display* display, const char* fontName)
{
	if(display == NULL)
		return NULL;

	XFontStruct* newFont = NULL;

	if(fontName == NULL)					// If fontName is not given then load default font
	{
		newFont = XLoadQueryFont(display, "fixed");
	} else {
		newFont = XLoadQueryFont(display, fontName);
	}

	if(newFont == NULL)					// Check if font has been loaded correctly
		fprintf(stderr, "sgui_Error: cannot load font \"%s\"\n", fontName == NULL ? "fixed" : fontName);

	return newFont;
}


// Unloads the specified font
void sgui_UnloadXFont(Display* display, Font font)
{
	if(display == NULL)
		return;

	XUnloadFont(display, font);
}


// Shows the native XWindow passed as parameter
void sgui_MapXWindow(Display* display, Window window)
{
	if(display == NULL)
		return;

	XMapWindow(display, window);
	XSync(display, 0);
}


// Removes from screen the native XWindow passed as parameter
void sgui_UnmapXWindow(Display* display, Window window)
{
	if(display == NULL)
		return;

	XUnmapWindow(display, window);
	XSync(display, 0);
}


// Creates and return an XColor struct with given values
Color_t sgui_Rgb(uint8_t red, uint8_t green, uint8_t blue)
{
	Color_t newColor = 0;

	newColor = blue;
	newColor += green << 8;
	newColor += red << 16;

	return newColor;
}


// This is the default function that is called when a textfield widget receives a key press event
void sgui_UpdateTextfield(Widget_t* widget, void* arg)
{
	char* inserted = (char*) arg;

	if(*inserted == 8)						// If user pressed the delete button
	{
		if(widget->cursorPos > 0)
			widget->cursorPos--;

		widget->text[widget->cursorPos] = '\0';			// Remove last char inserted

	} else {							// Otherwise
		if((widget->cursorPos + 1) <  MAX_TEXT_SIZE)		// If there is still space in the text buffer
		{
			widget->text[widget->cursorPos] = *inserted;	// Insert the inserted char in the text buffer
			widget->cursorPos++;
		}
	}

	sgui_RedrawWidget(widget);
}
